
DevOps 
CI
CD Delivery
CD Delploy

CNCF(Cloud Native Computing Foundation)

教程  （Spring cloud也有）
http://www.runoob.com/docker/docker-tutorial.html
https://www.katacoda.com 有学习docker的

https://docs.docker.com/install/linux/docker-ce/binaries/
https://download.docker.com/linux/static/stable/x86_64/

Docker 使用GO语言开发

比传统的虚拟机方式要快,统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。容器除了运行其中应用外，基本不消耗额外的系统资源
更快速的交付和部署
几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器

Dcoker Edge   是实验版本
最新的Docker 是基于runC 替代了 LXC (容器格式标准化),镜像格式也有标准化

创建一个轻量级私有PaaS云

 
echo "myapp-$(uname -s)-$(uname -m)"
docker 版本格式为<year>.<month> 如 18.09

软件自身官方有docker版本的有
sonarqube
Jenkins		
GitLab		gitlab/gitlab-ce

Jbpm7
SpringCloud	
	docker run -d -p 9411:9411 openzipkin/zipkin
	
swaggerapi/swagger-ui , swagger-editor
neo4j
kong
pgAdmin4
filebeat
#Codis

busybox 包含很命令，一个进程可创建出很链接，链成什么命令名就可直接用，如链成cat就是cat的功能
busybox 自带一个 httpd -f前台运行 -h 项目目录
默认主机名是容器的ID
docker run -h 指定新主机名

alpine linux (阿尔卑斯山的) 基于 Busybox
alpine-standard-3.10.2-x86_64.iso 要 112MB 
alpine-minirootfs-3.10.2-x86_64.tar.gz (用于containers)只有2.6MB

alpine 包管理工具 apk
apk add --no-cache gcc  linux-headers

上传本地java安装包(nginx) 到服务器 
docker load --input java1.8.tar


镜像（Image）
容器（Container）
仓库（Repository）  存放镜像文件的场所
 
 
----- 配置镜像仓库
vim /usr/lib/systemd/system/docker.service 
有 LimitNOFILE=1048576
#有   EnvironmentFile=/etc/sysconfig/docker
#也可 Environment="HTTPS_PROXY=https://docker.mirrors.ustc.edu.cn"
#	  Environment="NO_PROXY=localhost,127.0.0.1,10.96.0.0/12,192.168.99.0/24,192.168.39.0/24"
# 在dockerd后面加参数
ExecStart=/usr/bin/dockerd --registry-mirror=http://hub-mirror.c.163.com
----
systemctl daemon-reload
docker info 的HTTPS Proxy,No Proxy可看到配置Environment的值

--安装 docker engine   CentOS 下
yum-config-manager   --add-repo    https://download.docker.com/linux/centos/docker-ce.repo
	保存到 /etc/yum.repos.d/docker-ce.repo
	
yum install docker-ce   目前安装的是 17.12.0.ce-1.el7.centos 还依赖一个 container-selinux-2.36-1
 

或者 下载下来安装
https://download.docker.com/linux/centos/7/x86_64/stable/Packages/
https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-18.03.1.ce-1.el7.centos.x86_64.rpm 

yum install docker-ce-18.03.1.ce-1.el7.centos.x86_64.rpm 


http://mirrors.huaweicloud.com/centos/7/extras/x86_64/Packages/  
extra下有docker

---openSUSE
http://download.opensuse.org/distribution/leap/15.1/repo/oss/ 下的 x86_64/
 		docker-18.09.1
			docker-compose-1.17.0
			docker-machine-driver-kvm2-1.0.0
	
---linux  binary

https://download.docker.com/linux/static/stable/x86_64/
下载 docker-18.06.3-ce.tgz      docker-18.09.6.tgz
	
$ tar -zxvf docker-18.06.1-ce.tgz 
$ sudo cp docker/* /usr/bin/ 
$ sudo dockerd &
$sudo docker run hello-world  验证

https://download.docker.com/mac/static/stable/x86_64/    mac docker client
 $ sudo docker -H <hostname> run hello-world

--uninstall
	yum remove docker-ce
	sudo rm -rf /var/lib/docker
--

/var/lib/docker   是docker的数据目录 版本升级这个目录要移动/删除



systemctl start docker  
docker run hello-world  运行镜像,本地没有，会从网上下载

docker images 显示本地已有的镜像 (结果同docker image ls)

systemctl enable docker.service   配置开机启动
systemctl disable docker.service 

docker --version

看日志
journalctl -u docker.service

---默认只有root用户能仿问Unix socket ，所以都以root启动 docker daemon 
也可增加一个docker组（权限同root)
sudo groupadd docker
sudo usermod -aG docker dell   //-G是supplemental（追加的）组，-a是append用户 对supplemental
注销重新登录
newgrp docker 
docker run hello-world 就可以不用root了
 

--windows 10 版本使用  Hyper-V ,只用于开发(要求windows 10 pro or enterprise,windows server 2016)
最新版 windows 提示 You must be in the "docker-users" group. 
net user docker  /add /active:yes /expires:never /passwordchg:yes /fullname:"the-docker" /comment:"docker used"
net localgroup "docker-users" docker /add



docker pull ubuntu:12.04   // pull 命令来从仓库获取所需要的镜像。 最新的是 17.10

docker run -t -i ubuntu:12.04 /bin/bash   提示符是<CONTAINER ID>信息,也可以不退出docker container ls
	-i, --interactive           
	-t, --tty
xxx 命令 如的容器已经被我们改变了，使用 docker commit 命令来提交更新后的副本

docker commit -m "this is comment" -a "auther" <CONTAINER ID>   新REPOSITORY:新TAG 
-m --message 提交信息，-a --author 作者
后使用docker images 可以看到新建的(相同的IMAGE ID表示同一个镜像)，再次docker run -t -i  新REPOSITORY:新TAG 可以查看到修改的变化

 

docker run -d ubuntu:12.04  /bin/sh -c "while true; do echo hello world; sleep 1; done"
会返回一串xx

docker ps 查看运行的容器<CONTAINER ID>  和 <NAMES> 列
docker logs <CONTAINER ID>   看执行结果 可加 -f 监视标准输出
docker logs  <NAMES> 
docker stop <CONTAINER ID> 停止运行
docker stop  <NAMES> 


docker run -d -P training/webapp python app.py  #如本地没有从服务器上下载
-d detach 后台运行
-p 小p, --publish list                   Publish a container's port(s) to the host
-P 大P, --publish-all                    Publish all exposed ports to random ports
-e = env

docker ps 可以看到端口  0.0.0.0:32769->5000/tcp 表示本机是32769端口，可用浏览器看，docker是5000端口
docker run -d -p 4000:5000 training/webapp python app.py   小p指定端口
#-p 格式 本机端口:docker端口

docker port <CONTAINER ID>或<NAMES> 查看端口
docker top <CONTAINER ID>或<NAMES>  容器内部运行的进程
docker stats <CONTAINER ID>或<NAMES>   对CPU的占用
docker inspect <CONTAINER ID>或<NAMES>   会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息


docker ps -l 查询最后一次创建的容器：
docker rm  <CONTAINER ID>或<NAMES>  删除，必须先stop

docker search httpd 搜索镜像  有 OFFICIAL:是否docker官方发布

docker pull 显示的多行pull是分层下载
使用docker命令尽可能加子命令，如docker image rm,替代 docker rmi
docker ps 相当于 docker container ls

docker image ls --no-trunc 显示完整的 image_id

docker image ls |  awk -F' '  '{print $3}' |xargs  docker image rm  --force
docker container ls -a |  awk -F' '  '{print $1}' |xargs  docker container rm 


docker container ls 显示在正运行的镜像，是容器，结果同 docker ls ,docker ps 
docker container create <CONTAINER ID>  
docker container rm <CONTAINER ID>
docker container start <CONTAINER ID>  
docker container stop <CONTAINER ID>    
docker container kill <CONTAINER ID> 
 
docker container run <CONTAINER ID>   当相于 pull,create ,start 组合
docker container top  
 --rm 退出时自动删除
 docker inspect  <container_name> 有network的IP ,如 172.17.0.2 ，主机可以使用这个IP通讯
 连接主机的docker0网络IP为 172.17.0.1
 
docker ps -a 显示停止的容器
docker ls -a
docker container start -ai busybox   (-a == --attach  Attach STDOUT/STDERR  ) 
docker container start -d nginx (-d --detach)
 
容器中的进程不能进入后台运行，否则刚进入就终止

docker container exec -it redis1 /bin/sh


对只有一个进程的容器日志没有必须写日志，直接在控制台
docker container logs web1

docker镜像 是分层构建的，最底层是 bootfs 为启动,再上是rootfs 要文件系统,只读挂载的，联合挂载，再挂载一个可读写的
 
docker commit -p <container_id>   repository:tag
把容器对镜像的改写做成新的镜像  (-p pause让窗口暂停)
-c 修改指令，如cmd启动命令
-c "CMD ['/bin/httpd','-f', '-h', '/data/html']"
-a '作者'
docker inspect 镜像名，有 "Cmd":表示启动容器时执行的命令


docker commit -p -m "this is my busybox httpd" -a "dell" -c 'CMD ["/bin/httpd","-f","-h","/data/html"]' epic_lewin  busybox_httpd:0.0.1
-c 最外用单引号,数组中用双引号

docker login
docker push  (要事先在docker hub上建立repository如 busybox)








Dockerfile 指定是不区分大小写，通常大写，第一个非注释行必须是FROM
.dockerignore 类似.gitignore
所有shell命令是镜像的环境，${NAME:-default} 语法同linux shell
 
目录下有Dockerfile 文件 
	#基于哪个镜像
	FROM python:2.7-slim
	
	#维护人 信息 MAINTAINER(deprecated)
	#MAINTAINER  firstName lastName <usernme@docker.com>
	
	#格式 LABEL <key>=<value> <key>=<value>  ...
	LABEL  maintainer="SvenDowideit@home.org.au"
	LABEL version="1.0"
	LABEL description="This "

	#设置工作目录/app  (后面,dest目录可用.  进入shell默认目录)
	WORKDIR /app
	
	#复制当前目录 到 容器的/app目录  
	ADD . /app

	# RUN 后是命令 多条命令用 && 
	RUN pip install --trusted-host pypi.python.org -r requirements.txt

	#向外部开放 80端口  
	EXPOSE 80

	#ENV 环境变量,可后面指令和入口程序可使用，如一次定义多个 ENV key=val key1=val1 多行可用\
	ENV NAME World

	#CMD 容器启动时执行的命令
	CMD ["python", "app.py"]	
	
---
#当前目录下的src目录，src目录本身不会被复制，只能是Dockerfile 所在目录的下级，dest如是目录要以/结尾，dest目录不存在会自动创建 
可以多个源，目标必须是目录
COPY src /dest/ 	

每次指令生成一层，尽可能少的指令	

ADD 指令 源可以是网络上的文件 ，如源是本地的可识别的压缩包(gzip, bzip2 or xz)，会被解压 ，如是远程的是不会的

#只是容器的目录
VOLUME ["/data"]
启动时可不指定-v参数  自动绑定/var/lib/docker/volumes/<卷名>容器ID

#默认tcp可多个参数 ,docker run 时-P 就是这里的端口，如启动容器带http不指定-p 物理主机没有监听，同一个物理机内可通信
EXPOSE 80/udp 

docker run  printenv 可以看到Dockerfile中的环境变量 
		-env 是可以替换Dockerfile中的环境变量 

CMD "httpd" #shell格式 /bin/sh -c httpd
CMD ["httpd"] #exec格式 没有使用sh,就不能解析环境变量 ，这样也可["/bin/sh","-c","httpd"]  ,如http有参数都写在一个""中，多加数组无素无法启动?????

如进程不唯一，shell子进程，就不能用docker stop来停止

CMD ["param1","param2"] 是为ENTRYPOINT用的，
ENTRYPOINT 的命令，docker run 最后的参数不是覆盖入口，而是传递参数，如要覆盖使用参数 --entrypoint ls 不能加参数?????

docker inspect 查Entrypoint的值

USER  以启指定用户启动进程

健康检查
HEALTHCHECK [OPTIONS] CMD command
 	-interval=DURATION (default: 30s)
	--timeout=DURATION (default: 30s)
	--start-period= 等多长时启动
	--retries=N (default: 3)

SHELL  在linux默认是 ["/bin/sh", "-c"]，可修改为bash,windows 下默认是["cmd", "/S", "/C"]
STOPSIGNAL  修改stop时的发信号
ARG  只在build中使用 ，docker build --build-arg 的参数不能传到 第一个指令 FROM 中的值 
ONBUILD ADD . /app/src   是在生成镜像后，别人在from这个镜像时执行，是一个trigger



---
docker run -it --rm busybox httpd -f 可在最后传参数，替代默认启动命令

	
docker build -t friendlyhello .
  -t, --tag list                   Name and optionally a tag in the 'name:tag' format
  .表示 Dockerfile 文件所在目录
docker image ls查看制作的镜像 
  
  第一件事情就是上传这个 Dockerfile 内容
  同手工docker commit ,只是变成了批处理,所有的中间步骤所产生的容器都被删除和清理了 
  注意一个镜像不能超过 127 层，即FROM 子级的次数

docker run -p 4000:80 friendlyhello      #-p 格式 本机端口:docker端口
	-p, --publish list                   Publish a container's port(s) to the host

docker push username/repository:tag      上传到远程服务
docker run -p 4000:80 username/repository:tag 从服务器上下载运行


docker tag  <image id> <新repository名>  #新名必须全小写， 为镜像添加一个新的标签  
 
-- imort  和 export  配对用(导入要指定新的标签)
docker export   xx

cat ubuntu-14.04-x86_64-minimal.tar |docker import - ubuntu:14.04   
docker import ubuntu-14.04-x86_64-minimal.tar  ubuntu:14.04 

-- save 和 load配对用 (导入不用指定标签)
存出镜像 
docker save -o ubuntu12.04.tar ubuntu:12.04 	可多个镜像放一个文件中
docker load -i ubuntu12.04.tar  (-i ,input )


docker 容器可被限制使用 CPU，内存，
docker run/create 参数
 	   -m, --memory bytes             单位可m 内存开关 
      --memory-swap bytes            值为内存+swap ，-1 表示不限制
 		
 		--oom-kill-disable               Disable OOM Killer
      --oom-score-adj int              Tune host's OOM preferences (-1000 to 1000)

 -c, --cpu-shares int                CPU shares (relative weight) CPU是共享的，如每个容器都用CPU占权限比例分，如有一个不用CPU就会让出给其它容器分
      --cpus decimal                 Number of CPUs 可以用小数
		--cpuset-cpus						 允许在哪个核上运行 (0,1)或(0-3)

磁盘读写限制
  --device-read-bps list           Limit read rate (bytes per second)
  --device-write-bps list          Limit write rate (bytes per second) 
 
测试可docker hub 找stress的镜像
 
 
 
----docker 网络
Open vSwitch 软件模拟交换机

docker0的模拟网卡，当虚拟交换机用，当创建一个容器时 虚拟交换机建一个网口，容器建一个网口，vethe开头的网卡是 虚拟交换机的那一半,个数同当前运行的容器个数
vethe开头的网卡 都连接到docker0
brctl show 来看， ip link show ,显示@后的部分在容器中

每启动一个容器 iptables多一条 iptables -t nat -vnL   (-v --verbose, -L --list ,-n --numeric)

显示 Chain POSTROUTING 组
 pkts bytes target     prot opt in     out     source               destination         
 5   392 MASQUERADE  all  --  *      !docker0  172.17.0.0/16        0.0.0.0/0           
 
从任何网卡进入(in)，只要不是docker0网卡出去，源IP是 172.17网段，任何目标IP，都做MASQUERADE

ip 可操作的对像，如 netns 网络名称空间
ip netns list
ip netns add r1
ip netns add r2
ip netns exec r1 ip a s  默认只有一个lo网
ip link  add name veth1.1 type veth peer name veth1.2  建两个网卡做连接
ip link show/list

把一个网络设置称动名称空间中
ip link set dev veth1.2 netns r1
ip netns exec r1 ip a s 就有了新的网卡
ip netns exec r1 ip link set dev veth1.2 name eth0 对设备改名
ip netns exec r1 ip a s 显示修改后为  eth0@if42

设置IP
ip netns exec r1  ip addr change 10.0.0.1/24 dev eth0

激活
ip netns exec r1  ip link set dev eth0 up   好像不行？？？

ping 10.0.0.1 

再另一个名称空间做相同事，两个空间可以ping通
ip link set dev veth1.1 netns r2

docker run -ti -h mypc --dns 114.114.114.114  --dns-search xxx.io --add-host=www.abc.com:127.0.0.1 busybox 
cat /etc/resolve.conf
cat /etc/hosts

docker run --rm  -p 127.0.0.1::80 nginx  本要指定IP的随机端口 到 容器 80端口
docker run --rm  -p 127.0.0.1:80:80 nginx   本要指定IP的80端口 到 容器 80端口
docker run --rm  -p  80:80 -p  8080:80 --name web1  -d nginx   可多次使用-p
docker port <container_name/id>  查端口也可用 docker container ps

两个容器共用一个网卡
docker run --rm --name b1 -it busybox 
docker run --rm --name b2 --network container:b1 -it busybox 

https://docs.docker.com/engine/reference/commandline/dockerd
 	Daemon configuration file 和	Configuration reload behavior 有所有daemon.json可用的值

修改docker0网卡的ip
/etc/docker/daemon.json
{
"bip":"10.0.0.1/16"
}
bip是bridge ip
systemctl restart docker

docker -H --host 默认本机的/var/run/docker.sock

修改docker服务可以被远程连接 
要求/usr/lib/systemd/system/docker.service 中ExecStart 不能有 -H选项，如有去除后要 systemctl daemon-reload
/etc/docker/daemon.json
{
"hosts":["tcp://0.0.0.0:2375","unix:///var/run/docker.sock"]
}

 

docker network create -d bridge --subnet "172.26.0.0/24" --gateway "172.26.0.1" docker_br0
-d --driver s
ip a s 按设置IP查找，发现网卡名是乱的
ip link set dev br-104a647ce6d5 name d_br0  提示busy, 网卡down  
ip link set dev br-104a647ce6d5 down
 
同一个物理主机上的不同容器 使用不同的网桥，网段不一样，要通讯 设置  cat /proc/sys/net/ipv4/ip_forward 显示1
iptables 有很多规则阻止通讯
 
 
 

docker network ls  显示有建立的网，Driver 三种常见的网络模式，分别是none(null),bridge,host
docker network -help
docker run --help

docker network inspect [建立的网络名，如bridge1]
docker network inspect none
docker network inspect host
docker network inspect bridge 


docker run -it --network=none busybox
#ifconfig

docker run -it --network=host busybox
#ifconfig

host方式性能比较好，	主机上使用的端口，容器不能继续使用

(bridge-utils软件包) brctl show 显示 docker0, 如果有容器运行的是bridge的网络模式，就会把虚拟网卡挂在docker0

docker run -it --network=bridge busybox

docker network create --help

docker network create --driver bridge bridge1
ip a s创建了个 br-xx的网卡
docker network ls显示bridge1

docker network create --driver bridge --subnet 172.19.16.0/24 --gateway 172.19.16.1 bridge2
(172.19是目前网卡中没有的网段 , ip route show可以看到网关地址)

docker run -it --network=bridge2 busybox 进入后ifconfig看IP网段是172.19.16的

docker run -it --network=bridge2 --ip=172.19.16.3 busybox   指定容器的IP
docker run -it --network=bridge2 --ip=172.19.16.4 busybox   再启动一个容器，两个容器可以网互通
 
基于Docker DNS之间的互联互通
docker run -it --network=bridge2 --name=busyboxone busybox
docker run -it --network=bridge2 --name=busyboxtwo busybox

通过127.0.0.1进行通信，无法验证？？？？
docker run -it --name web1 httpd
docker ps -a

docker run -it --name web1 httpd --rm
docker run -it --network=container:web1 httpd

docker默认的网络是bridge网络，因此只要docker host可以连接互联网

tcpdump -i docker0 -n icmp

----网络驱动
bridge网络驱动是默认的，用于单机容器(standalone)
host网络驱动也是用于单机容器(standalone),  容器使用主机的网卡
macvlan网络驱动，分容器分配一个MAC地址，在网络就有一个物理设置，docker主机通过mac地址路由

----overlay网络驱动
两个容器通信物数据包源和目标的IP不改，再加一层数据包是物理机的源和目标的IP

不需要操作系统的路由
让swarm service 和 standalone containe通信
也可在两个不同的dockerd后进程中的容器通信 

分布式的,跨多个docker主机的网络，在物理主机网络的上层,on top of (overlay)

https://docs.docker.com/network/overlay/
docker network create --driver overlay my-network
docker network create -d overlay my-overlay
这种只能用于swarm service.

如要用于swarm service 或 单机容器 和 其它单机容器通信，要加 --attachable
docker network create -d overlay --attachable my-attachable-overlay
可以指定地址范围，子网，网关  

swarm service 的网络默认是加密的，使用AES算法

选项 --opt encrypted  启用IPSEC(IP层加密协议) 加密

docker network create --opt encrypted --driver overlay --attachable my-attachable-multi-host-network
(不能在windows 上 attachable 到一个加密的overlay网络 )

自定义ingress网络
#docker network rm ingress (ingress类型网络只可一个)
docker network create \
  --driver overlay \
  --ingress \
  --subnet=10.11.0.0/16 \
  --gateway=10.11.0.2 \
  --opt com.docker.network.driver.mtu=1200 \
  my-ingress
  
  MTU(max transmission unit) ,这个值最大能是1500，数据链路层允许的最大IP包
  
自定义docker_gwbridge网络
sudo ip link set docker_gwbridge down
sudo ip link del dev docker_gwbridge

docker network create \
--subnet 10.11.0.0/16 \
--opt com.docker.network.bridge.name=docker_gwbridge \
--opt com.docker.network.bridge.enable_icc=false \
--opt com.docker.network.bridge.enable_ip_masquerade=true \
docker_gwbridge

 Inter Container Connectivity(ICC)
 

-----docker iptables
https://docs.docker.com/network/iptables/

Docker 会插入iptales策略

iptables -L 
有一个名为 DOCKER 的chain ，是所有docker ipables规则，不要手工修改
可以手式增加到 DOCKER-USER 的chain ，是在所的DOCKER 的chain加载之前，加载

默认所有IP都可以连接Docker daemon
指定IP可以仿问Docker daemon
iptables -I DOCKER-USER -i p4p2 ! -s 192.168.1.1 -j DROP

    --insert  -I chain [rulenum]
	-s 值可以是一个子网  192.168.1.0/24

当使用--src-range 或 --dst-range是要增加 -m iprange 选项  
iptables -I DOCKER-USER -m iprange -i p4p2 ! --src-range 192.168.1.1-192.168.1.3 -j DROP

iptables -D DOCKER-USER 1 
删DOCKER-USER第1行
  
-------bind mounts
-v -volume 标志  当主机目录不存在，会创建目录
--mount 标志是为docker swarm 的service，（也可docker run）当主机目录不存在，会报错

$ docker run -d \
  -it \
  --name devtest \
  --mount type=bind,source="$(pwd)"/target,target=/app \
  nginx:latest

效果同

  docker run -d \
  -it \
  --name devtest \
  -v "$(pwd)"/target:/app \
  nginx:latest
  
  type选项还可是 volume tmpfs 
 
 还可以只读挂载
 $ docker run -d \
  -it \
  --name devtest \
  --mount type=bind,source="$(pwd)"/target,target=/app,readonly \
  nginx:latest
  
docker inspect devtest  
    "Mounts": [
            {
                "Type": "bind",
                "Source": "/home/dell/target",
                "Destination": "/app",
                "RW": false,
                "Propagation": "rprivate"

 
			...
			}
		]

如只支持定容器目录，物理主机目录自动生成在 /var/lib/docker/volumes/<卷名>/_data
docker  run -it --name b1 -v /data  --rm busybox
主机目录和容器目录如不存在，会自动创建
多个容器可使用相同的物理主机的目录

Propagation 默认是  rprivate （r表示replica），只linux主机生效，通常不需要配置
是否传播到 replacas的挂载点
docker run -d \
  -it \
  --name devtest \
  --mount type=bind,source="$(pwd)"/target,target=/app \
  --mount type=bind,source="$(pwd)"/target,target=/app2,readonly,bind-propagation=rslave \
  nginx:latest

建立/app/foo/目录  /app2/foo/ 也存在








----docker volume
https://docs.docker.com/storage/volumes/

docker run -d -P --name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py
:ro 之后,就挂载为只读了
-d --detach
 
sudo docker run -it -v /tmp/docker_data/:/opt ubuntu /bin/bash

:前是主机目录，:后是容器中的目录

sudo docker run -it -v /tmp/docker_data/:/opt:ro ubuntu /bin/bash
:ro 之后,就挂载为只读了


创建数据卷容器，专门用来提供数据卷供其它容器挂载的

docker volume create my-vol
docker volume ls
docker volume inspect my-vol  显示本地目录为 /var/lib/docker/volumes/my-vol/_data
docker volume rm my-vol

docker run -d \
  --name devtest \
  --mount source=my-vol,target=/app \
  nginx:latest

docker container stop devtest  有stop 就有start
docker container rm devtest
docker volume rm myvol2


容器自带volume
docker run -d \
  --name devtest \
  -v myvol2:/app \
  nginx:latest
		
		
表示 卷给容器的/app目录   
--mount 或 -v


docker  inspect devtest 显示信息
  "Source": "/var/lib/docker/volumes/myvol2/_data",
  "Destination": "/app",
  "RW": true,

 服务带volume
 docker service create -d \
  --replicas=4 \
  --name devtest-service \
  --mount source=myvol2,target=/app \
  nginx:latest

报 Error response from daemon: This node is not a swarm manager. Use "docker swarm init" or "docker swarm join" to connect this node to swarm and try again.

docker service ps devtest-service
docker service rm devtest-service


--mount的只读
docker run -d \
  --name=nginxtest \
  --mount source=nginx-vol,destination=/usr/share/nginx/html,readonly \
  nginx:latest


docker run --rm --volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata

卷和网络都可指定使用另一个容器的
docker run --name b2 --network container:b1 --volumes-from b1 -it busybox 对于b1可以启动，只要存在就可

----OverlayFS 存储驱动
存储驱动(storage driver) ,数据存储在容器中，容器删除数据删除，性能要比原始的本地文件系统要低
	OverlayFS 类似 AUFS(union filesystem,是老的方式)，但比AUFS更快更简单
	还有VFS(不是union filesystem，不支持copy-on-write，性能低，占用空间大)
		ZFS(只Ubuntu上用)
		btrfs(只推荐在Ubuntu 或 Debian上用)可选


原始的overlay
现在有新的 overlay2 更高效, 要求linux kernel-4.0
https://docs.docker.com/storage/storagedriver/overlayfs-driver/

overlay 和 overlay2 也支持 xfs (要配置d_type=true) 
docker info 显示
Storage Driver: overlay2
Backing Filesystem: extfs  （物理主机的分区,可xfs）

linux可使用 tmpfs mount，windows可使用named pipe



--docker.io镜像加速
https://www.ilanni.com/?p=14534

docker pull  mysql:5.7 
因有提示 5.7: Pulling from library/mysql
所以
docker pull docker.mirrors.ustc.edu.cn/library/mysql:5.7
docker pull dockerhub.azk8s.cn/library/mysql:5.7

--配置镜像 
vi /etc/docker/daemon.json 文件不存在，新建
{
    "registry-mirrors": [
       "https://docker.mirrors.ustc.edu.cn"
   ]
}

docker info 可以看到有 Registry Mirrors 字段

-------registry 私有仓库
Redhat 的Extra 上有 docker-distribution  
	配置文件 /etc/docker-distribution/registry/config.yml
		端口5000
		镜像目录 /var/lib/registry
		systemctl start docker-distribution  
openSUSE 有  docker-distribution-registry 使用go语言写的
		配置文件	/etc/registry/config.yml  
		镜像目录	/var/lib/docker-registry
		registry serve /etc/registry/config.yml
		
		
https://docs.docker.com/registry/  

docker run -d -p 5000:5000 --name registry registry:2    仿问 http://127.0.0.1:5000/v2/  返回{} 

docker pull ubuntu  
docker image tag ubuntu localhost:5000/myfirstimage 
docker push localhost:5000/myfirstimage  		推到私服		仿问 http://127.0.0.1:5000/v2/_catalog 返回 {"repositories":["myfirstimage"]}
默认registry只可https方式，如要使用http daemon.json 中配置 insecure-registries:["host:port"]


删本地缓存
docker image remove ubuntu
docker image remove localhost:5000/myfirstimage

docker pull localhost:5000/myfirstimage 		从私服下载
docker container stop registry && docker container rm -v registry   # -v 也删除相关的volume



docker run -d -p 5000:5000 registry
默认情况下，仓库会被创建在容器的 /tmp/registry 下

docker run -d -p 5000:5000 -v /opt/data/registry:/tmp/registry registry
-v volum  , : 前是本地目录 ,: 后docker目录

-e REGISTRY_HTTP_ADDR=0.0.0.0:5001 修改默认监听端口 , 和 -p 一起使用 测试成功


指定配置文件
https://docs.docker.com/registry/configuration/

--config.yml
 
storage:
  filesystem:
    rootdirectory: /opt/data/registry
				
-e REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY=/opt/data/registry   覆盖方式（没有测试出来效果）

docker run -d  -e REGISTRY_HTTP_ADDR=0.0.0.0:5001 -p 5001:5001 -e REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY=/opt/data/registry   registry

		
$ docker run -d -p 5000:5000 --restart=always --name registry \
             -v `pwd`/config.yml:/etc/docker/registry/config.yml \
             registry:2

-------私有仓库Harbor 基于Registry 支持HA
看文档，下载离线版本 harbor-offline-installer-v1.8.2 ，解压 修改 harbor.yml配置文件 ，有些选项必须修改
	如hostname:
	默认用户 admin/Harbor12345
	默认数据用户 root/root123
	默认log
	要docker-compose  版本>= 1.18.0  用 sudo pip install -U docker-compose
sudo ./install.sh
registry和redis 镜像/容器不能存在

停止服务 docker-compose stop 

-------私有仓库 nexus
https://help.sonatype.com/repomanager3
https://help.sonatype.com/repomanager3/formats/docker-registry

上方第二个设置(Server Administration and Configuration)按钮 -> 左侧菜单 Repository->Repositories-> Create Repository 按钮->
docker(hosted) 可用于上传本私服
docker(proxy) 可配置公网 Remote Storage 填入	 	 
	 http://hub-mirror.c.163.com
docker(group) 上面建的两个放一起(最好hosted类型的放最上)
	如建的名为 docker-group 生成路径为 http://127.0.0.1:8081/repository/docker-group/


----- 指向私有仓库
vim /usr/lib/systemd/system/docker.service 
# 在dockerd后面加参数
ExecStart=/usr/bin/dockerd --registry-mirror=http://127.0.0.1:8081/repository/docker-group/
不行？？？
/etc/docker/daemon.json  (openSUSE-leap-15.1 是 /etc/daemon.js)

=============== Docker Swarm
https://docs.docker.com/engine/swarm/
Swarm mode
Docker Swarm 是集成在docker引擎中,  管理docker引擎集群

manager节点
worker节点
---
如要使用swarm，则必须让Docker开放其HTTP的API。默认情况下这个API没有开启
openSUSE/Redhat一样的systemctl 都改 /usr/lib/systemd/system/docker.service 中的 ExecStart 参数
ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock
(原来没-H参数，启动后就监听2375端口) 
docker -H --host 去连接服务端
 
docker info 报 WARNING  不安全
 　　 
修改完成之后别忘了运行一下systemctl daemon-reload刷新配置   
ss -atn | grep 2735
   -n, --numeric

docker pull swarm   下载swarm的镜像

docker run --rm swarm create  提示这种方式过时了
 
 ---

TCP 端口2377 for cluster management communications
--为routing mesh
TCP/UDP 端口 7946 for communication among nodes
UDP 端口 4789 for overlay network traffic

如果使用docker-machine创建的主机
 docker-machine ssh manager1
 
 docker swarm init --advertise-addr <MANAGER-IP>
 会提示当前节点是manager，增加work要运行  docker swarm join  --token xxx  <manager-ip>:2377,增加manager运行 docker swarm join-token manager
 会创建名为 ingress 的overlay网络,名为docker_gwbridge 的bridge网络

 在docker swarm join时，报 Root CA Certificate: x509: certificate has expired  
 docker swarm leave --force 删除后，同步worker，manager时间，再docker swarm init即可

 docker info 
 	看Swarm组值为active 
 		 Is Manager: true
 		 Managers: 1
 		 Nodes: 2

 docker node ls 看MANAGER列值为Leader
 
 
如--token丢失，在manager上执行 下面命令，会再次提示增加work命令
docker swarm join-token worker

在manager节点上创建service（不是必需的）
docker service create --replicas 1 --name helloworld alpine ping docker.com

Service 包含两种模式：
	replicated：可指定服务驻留节点数量（默认）
	global：服务驻留在全部节点

docker service ls
docker service inspect --pretty helloworld  （如不加--pretty 返回json)
docker service ps helloworld  看哪个节点在运行

docker service scale helloworld=5
docker service ps helloworld 显示哪个节点有运行
在运行的节点上查看 docker ps 

docker service rm helloworld  刚运行的节点docker ps 就没了

 -----滚动更新
 在manager节点上
 docker service create \
  --replicas 3 \
  --name redis \
  --update-delay 10s \
  redis:3.0.6

  --update-delay  s秒 ,m分, h小时.  10m30s  10分30秒
默认1个任务 ，可以配置 --update-parallelism
默认更新失败就暂停,可以在 docker service create 或 docker service update 命令中增加 --update-failure-action
 


docker service inspect --pretty redis
可以看到
Service Mode:   Replicated
 Replicas:      3
UpdateConfig:
 Parallelism:	1
 Delay:		10s
 On failure:	pause
ContainerSpec:
 Image:		redis:3.0.6@sha256:xxx
 
开始更新
 docker service update --image redis:3.0.7 redis

docker service inspect --pretty redis
看 Image:		版本有升级

更新暂停的情况 （如edis:3.0.8）
UpdateConfig:  
 On failure:	pause

对更新暂停的，要再次更新使用命令
docker service update redis

docker service ps redis 会看到有各版本的运行状态

DRAIN （	排空; (使) 喝干; 下水道; ） 能力，不从swarm manager接受新任务，把任务复制到其它 活动 能力 节点上，并不删除 
docker node ls 可以看到 AVAILABILITY 列

docker node update --availability drain <NODE-ID>  (docker node ls的ID或HOSTNAME)
docker node update --availability drain rhel7

docker node inspect --pretty rhel7
有信息
Status:
 State:			Ready
 Availability:         	Drain

再激活
docker node update --availability active rhel7


---routing mesh
TCP/UDP 端口 7946 for communication among nodes
UDP 端口 4789 for overlay network traffic

docker service create \
  --name my-web \
  --publish published=8080,target=80 \
  --replicas 2 \
  nginx
  
published  如不写,就会随机高数字端口，target 表示 <CONTAINER-PORT>
#类似 -p 格式 本机端口:docker端口


ingress netwok  图显示有 load balance功能, 在任何节点访问8080端口时，Docker路由将把请求分发到一个active的容器中
docker network ls 显示有ingress记录

如果是已经存的服务使用命令

docker service update \
  --publish-add published=<PUBLISHED-PORT>,target=<CONTAINER-PORT> \
  <SERVICE>

docker service inspect --format="{{json .Endpoint.Spec.Ports}}" my-web  使用json查找只要部分数据
使用Go template

docker service inspect --pretty  my-web
Ports:
 PublishedPort = 8080
  Protocol = tcp
  TargetPort = 80
  PublishMode = ingress 


默认是tcp协议 

$ docker service create --name dns-cache \
  --publish published=53,target=53 \
  dns-cache 

 缩写方式
  
$ docker service create --name dns-cache \
  -p 53:53 \
  dns-cache



指定协议UDP 

$ docker service create --name dns-cache \ 
  --publish published=53,target=53,protocol=udp \
  dns-cache

 缩写方式

$ docker service create --name dns-cache \ 
  -p 53:53/udp \
  dns-cache


绕过路由网络，必须使用长格式的  --publish参数
 docker service create --name dns-cache \
  --publish published=53,target=53,protocol=udp,mode=host \
  --mode global \
  dns-cache

对于 mode=host     默认值为  ingress
对于 --mode global 默认值为 replicated



可以最前方增加 Haproxy 代理 (网上说单独性能超nginx)
https://docs.docker.com/engine/swarm/ingress/#bypass-the-routing-mesh


如不使用路由网络
--endpoint-mode=dnsrr   

DNS Round Robin (DNSRR) 
默认值是vip (virtual IP)

docker service inspect --pretty  my-web
显示有 Endpoint Mode:	vip

-----
如使用私有 registry 要密码，建立serivce 使用参数 --with-registry-auth

$ docker login registry.example.com

$ docker service  create \
  --with-registry-auth \
  --name my_service \
  registry.example.com/acme/my_image:latest
  
--env MYVAR=myvalue  
--workdir /tmp  	 是容器内的工作目录
--user my_user  

如使用overlay网络
$ docker network create --driver overlay my-network

docker service create \
  --replicas 3 \
  --network my-network \
  --name my-web \
  nginx

对已经存的service 的网络修改
  
docker service update --network-add my-network my-web
docker service update --network-rm my-network my-web


--config  

docker ps --filter name=my-web -q
查看docker容器的目录
docker container exec $(docker ps --filter name=my-web -q) ls -l /   
 
技巧 利用sh 可以执行命令
docker run -d --name app1 registry
docker exec -it app1 sh 
可以看ip,ping



echo "This is a config" | docker config create my-config  -
- 从标准输入传读，
docker service create --name redis --config my-config redis:alpine 
默认仿问/my-config，可以使用target自定义文件名
docker service update --config-add my-config redis
#docker service update --config-rm my-config redis

docker ps --filter name=redis -q
docker container exec $(docker ps --filter name=redis -q) ls -l /my-config
docker container exec $(docker ps --filter name=redis -q) cat /my-config                                               
docker config ls

docker service rm redis
docker config rm my-config


禁用 docker swarm
docker swarm leave 如有其它主机加入会提示
(master)使用 docker swarm leave --force 
后再docker info 看 Swarm: inactive


=============== Docker compose
用于单机的容器编排工具，可以先做镜像，容器可以按顺序启动，自动配置容器，(如多物理机用docker-swarm，加入docker-swarm要求用docker-machine)
更强的kubernetes

使用python开发

https://docs.docker.com/compose/overview/
一个工具 用于 定义和运行 多个docker应用

docker-compose-1.17.0-lp151.3.2.noarch.rpm

openSUSE-leap-15.1 DVD带的依赖
rpm -ivh ../noarch/python2-appdirs-1.4.3-lp151.2.1.noarch.rpm ../noarch/python2-setuptools-40.5.0-lp151.1.1.noarch.rpm ../noarch/python2-packaging-16.8-lp151.2.1.noarch.rpm ../noarch/python2-pyparsing-2.2.0-lp151.2.1.noarch.rpm ../noarch/python2-six-1.11.0-lp151.3.1.noarch.rpm ../noarch/python2-chardet-3.0.4-lp151.3.2.noarch.rpm

最新版本1.24.1
curl -L  https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose
curl -L "https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose

下载地址
https://dl.bintray.com/docker-compose/master/


Docker compose pip 安装
yum install python-pip python-dev
pip install -U docker-compose
卸载
pip uninstall docker-compose
rm /usr/local/bin/docker-compose

docker-compose --version 

1.定义Dockerfile
2.定义 docker-compose.yml  		 version为 3.7	要示docker18.06.0+ 
3.运行 docker-compose up 启动和运行所有应用

docker-compose down


https://docs.docker.com/compose/compose-file/
--docker-compose.yml 
version: '3'
services:
  db:
    image: postgres
  web:
    build: .
    command: python manage.py runserver 0.0.0.0:8000
    ports:
    - "5000:5000"
    volumes:
    - .:/code
    - logvolume01:/var/log
    environment:
      FLASK_ENV: development
    links:
    - redis
    depends_on:
      - db
  redis:
    image: redis
volumes:
  logvolume01: {}
  
 --
 https://docs.docker.com/compose/gettingstarted/
 
services下的两自定义名为web的使用dockerFile构建，名为redis要拉镜像
volumes :前是主机目录，:后是容器目录
environment 环境变量 
depends_on 依赖服务名 
command 覆盖默认 command(应该是dockerFile的CMD??)

控制台提示 如是在docker swarm下使用docker-compose 使用命令 docker stack deploy 


docker-compose scala/logs

----docker stack 
(要求docker-compose.yaml版本为3,API版本至少 1.25 )
docker info 看API版本
	 Version:           18.09.1
 	 API version:       1.39

格式 docker stack deploy [OPTIONS] STACK

##docker deploy 命令目前还是实验阶段 

docker stack  ls

docker stack 选项
      --kubeconfig string     Kubernetes config file
      --orchestrator string   Orchestrator to use (swarm|kubernetes|all)

ORCHESTRATOR (orchestrate 编管弦乐曲;精心安排；把…协调地结合起来 )

docker stack deploy --help
	 -c, --compose-file strings   Path to a Compose file, or "-" to read from stdin
	 --orchestrator string    Orchestrator to use (swarm|kubernetes|all)


----

如使用 docker-compose up -d 即detached，可以用 docker-compose ps 查看

docker-compose run web env 看名为web的service 环境变量 


docker-compose stop  #用docker-compose ps可看service记录，状态为Exit ,而docker-compose down 根本看不到记录
docker-compose down --volumes 也删除容器中的卷,声明在docker-compose.yml文件中的

docker-compose help

docker-compose -f docker-compose.yml -f docker-compose.admin.yml  pull db
  两配置文件合并，如相同后面覆盖前面的，把名为db的serivice下载镜像即image:的值

  
===============  docker machine
https://docs.docker.com/machine/

download url
https://github.com/docker/machine/releases/

curl -L https://github.com/docker/machine/releases/download/v0.16.1/docker-machine-`uname -s`-`uname -m` >/tmp/docker-machine 
chmod +x /tmp/docker-machine 
sudo cp /tmp/docker-machine /usr/local/bin/docker-machine

使用docker-machine 可以在windows和mac上安装和运行docker,把docker安装在虚拟机中
可以高效的provision 和管理 多个远程的docker主机

docker run等命令其实通过 REST API 完成的

Docker Desktop for Mac 使用  --driver virtualbox 
Docker Desktop for Windows 使用 -driver hyperv 

建立名为default,安装virtualBox后/usr/bin/VBoxManage
docker-machine create --driver virtualbox default   也要下载boot2docker.iso 即从 https://github.com/boot2docker/boot2docker/releases

docker-machine ls
docker-machine ip <MACHINE-NAME>
docker-machine env default
docker-machine stop default
docker-machine start default



--- docker-machine 采用generic驱动
https://www.cnblogs.com/jsonhc/p/7784466.html
 
官网 https://docs.docker.com/machine/drivers/generic/
root用户执行
#ssh-keygen
#ssh-copy-id root@192.168.1.102  是本机IP ，表示 use locally available keys to authorise logins on a remote machine  

#docker-machine create -d generic --generic-ip-address=192.168.1.102 --generic-ssh-key ~/.ssh/id_rsa --generic-ssh-user=root vm
提示多次输入密码，后报 执行sudo hostname vm && echo "vm" | sudo tee /etc/hostname  失败,只能以root用户执行 又报  sudo -E zypper -n in docker 错误要事先安装好

 --generic-ip-address 是本机IP  也可是远程IP
 
#docker-machine ls  显示 
NAME   ACTIVE   DRIVER    STATE     URL                        SWARM   DOCKER     ERRORS
vm     -        generic   Running   tcp://192.168.1.102:2376           v18.09.1   

#docker-machine env vm
加载到环境变量 ，后面操作会使用这些变量
#eval $(docker-machine env vm)

docker run -d --name=nginx nginx  修改也 同步 指定IP的操作
docker ps -a 查本地有
docker-machine ssh vm 登录查远程docker ps -a 也有，并且容器ID相同

#docker-machine rm  vm
 
---------Docker集中化web界面管理平台 shipyard
curl -sSL https://shipyard-project.com/deploy | bash -s
	 -L, --location 
	 -S, --show-error
	 -s, --silent  
	bash -s  从标准输入读命令
安装后 http://ip:8080 

-------------portainer   Docker的图形化管理工具

docker search portainer
docker pull portainer/portainer

单机运行
docker run -d -p 9000:9000 \
    --restart=always \
    -v /var/run/docker.sock:/var/run/docker.sock \
    --name prtainer-test \
    portainer/portainer 

http://127.0.0.1:9000/  进入界面设置admin密码
 选择Local Docker环境 页面提示启动要有参数 -v "/var/run/docker.sock:/var/run/docker.sock"  -> Connect按钮
 	,可以管理Service,Container,Image,Volums,Networks,左侧工具栏的Config，Secrets,Swarms按钮

docker ps -a
docker rm prtainer-test
集群运行启动  不用加  -v "/var/run/docker.sock:/var/run/docker.sock" 
docker run -d -p 9000:9000 \
    --restart=always \ 
    --name prtainer-test \
    portainer/portainer
 会再次创建amin用户 
		选择Remote Docker环境->  Endpoint URL (2375端口)要求远程docker 启用 Docker API over TCP
---- 启用 Docker API over TCP
 https://docs.docker.com/engine/security/https/
 
 在docker daemon执行
 openssl genrsa -aes256 -out ca-key.pem 4096
 提示输入最少4位密码
 
 openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem  
 提示输入很多信息
 
 openssl genrsa -out server-key.pem 4096
 
 创建 certificate signing request (CSR)
 把$HOST替换为docker daemon执行的DNS主机名字
 openssl req -subj "/CN=$HOST" -sha256 -new -key server-key.pem -out server.csr

充许连接的IP(白名单，包含客户端地址)
$ echo subjectAltName = DNS:$HOST,IP:10.10.10.20,IP:127.0.0.1 >> extfile.cnf
即
echo subjectAltName = DNS:rhel7,IP:10.31.194.124,IP:127.0.0.1 >> extfile.cnf

$ echo extendedKeyUsage = serverAuth >> extfile.cnf

 openssl x509 -req -days 365 -sha256 -in server.csr -CA ca.pem -CAkey ca-key.pem \
  -CAcreateserial -out server-cert.pem -extfile extfile.cnf
 
openssl genrsa -out key.pem 4096
openssl req -subj '/CN=client' -new -key key.pem -out client.csr
echo extendedKeyUsage = clientAuth > extfile-client.cnf
openssl x509 -req -days 365 -sha256 -in client.csr -CA ca.pem -CAkey ca-key.pem \
  -CAcreateserial -out cert.pem -extfile extfile-client.cnf

因已经生成了 cert.pem 和 server-cert.pem
rm -v client.csr server.csr extfile.cnf extfile-client.cnf
chmod -v 0400 ca-key.pem key.pem server-key.pem
chmod -v 0444 ca.pem server-cert.pem cert.pem

服务端启动docker方式
dockerd --tlsverify --tlscacert=ca.pem --tlscert=server-cert.pem --tlskey=server-key.pem \
  -H=0.0.0.0:2376

docker客户端运行 要可以ping通$HOST的值，测试成功
docker --tlsverify --tlscacert=ca.pem --tlscert=cert.pem --tlskey=key.pem \
  -H=$HOST:2376 version

$HOST不能是IP地址 即
docker --tlsverify --tlscacert=ca.pem --tlscert=cert.pem --tlskey=key.pem \
  -H=rhel7:2376 version
  
--tlscacert  默认位置 ~/.docker/ca.pem
--tlscert    默认位置 ~/.docker/cert.pem
--tlskey     默认位置 ~/.docker/key.pem

export DOCKER_HOST=tcp://$HOST:2376 DOCKER_TLS_VERIFY=1
就可以直接 docker ps  (测试成功)

---
portainer使用证书连接不行？？？,可能版本问题

----
docker run -d -p 8400:8400 -p 8500:8500 -p 8600:53/udp -h consul 
 
  
=================== etcd

https://github.com/etcd-io/etcd/
使用GO语言开发 ，用来替代 zookeeper (openstack使用这个)
 

下载地址
https://github.com/etcd-io/etcd/releases
v3.3.13
 
./etcd 监听 2379 用来和客户端通讯
							监听	2380 用来服务端和服务端通讯

./etcdctl set mykey "this is awesome"  #官方文档的put是错的
./etcdctl get mykey

--etcd集群
https://github.com/etcd-io/etcd/blob/master/Documentation/demo.md

TOKEN=token-01
CLUSTER_STATE=new
NAME_1=machine-1
NAME_2=machine-2
NAME_3=machine-3
HOST_1=10.240.0.17
HOST_2=10.240.0.18
HOST_3=10.240.0.19
CLUSTER=${NAME_1}=http://${HOST_1}:2380,${NAME_2}=http://${HOST_2}:2380,${NAME_3}=http://${HOST_3}:2380


# For machine 1
THIS_NAME=${NAME_1}
THIS_IP=${HOST_1}
etcd --data-dir=data.etcd --name ${THIS_NAME} \
	--initial-advertise-peer-urls http://${THIS_IP}:2380 --listen-peer-urls http://${THIS_IP}:2380 \
	--advertise-client-urls http://${THIS_IP}:2379 --listen-client-urls http://${THIS_IP}:2379 \
	--initial-cluster ${CLUSTER} \
	--initial-cluster-state ${CLUSTER_STATE} --initial-cluster-token ${TOKEN}

类似再加两节点，建立集群


客户端
export ETCDCTL_API=3
HOST_1=10.240.0.17
HOST_2=10.240.0.18
HOST_3=10.240.0.19
ENDPOINTS=$HOST_1:2379,$HOST_2:2379,$HOST_3:2379

etcdctl --endpoints=$ENDPOINTS member list


etcdctl --endpoints=$ENDPOINTS put foo "Hello World!"  
etcdctl --endpoints=$ENDPOINTS get foo
etcdctl --endpoints=$ENDPOINTS --write-out="json" get foo

etcdctl --endpoints=$ENDPOINTS put web1 value1
etcdctl --endpoints=$ENDPOINTS put web2 value2
etcdctl --endpoints=$ENDPOINTS put web3 value3 
etcdctl --endpoints=$ENDPOINTS get web --prefix


etcdctl --endpoints=$ENDPOINTS put key myvalue
etcdctl --endpoints=$ENDPOINTS del key

etcdctl --endpoints=$ENDPOINTS put k1 value1
etcdctl --endpoints=$ENDPOINTS put k2 value2
etcdctl --endpoints=$ENDPOINTS del k --prefix


#txn 带事务的要试
etcdctl --endpoints=$ENDPOINTS put user1 bad
etcdctl --endpoints=$ENDPOINTS txn --interactive 


#watch
etcdctl --endpoints=$ENDPOINTS watch stock1
etcdctl --endpoints=$ENDPOINTS put stock1 1000

etcdctl --endpoints=$ENDPOINTS watch stock --prefix
etcdctl --endpoints=$ENDPOINTS put stock1 10
etcdctl --endpoints=$ENDPOINTS put stock2 20





#租用时间
etcdctl --endpoints=$ENDPOINTS lease grant 300
# lease 2be7547fbc6a5afa granted with TTL(300s)

etcdctl --endpoints=$ENDPOINTS put sample value --lease=2be7547fbc6a5afa
etcdctl --endpoints=$ENDPOINTS get sample

etcdctl --endpoints=$ENDPOINTS lease keep-alive 2be7547fbc6a5afa
etcdctl --endpoints=$ENDPOINTS lease revoke 2be7547fbc6a5afa
# or after 300 seconds
etcdctl --endpoints=$ENDPOINTS get sample


#分布式锁

etcdctl --endpoints=$ENDPOINTS lock mutex1

# another client with the same name blocks
etcdctl --endpoints=$ENDPOINTS lock mutex1


#选举
etcdctl --endpoints=$ENDPOINTS elect one p1

# another client with the same name blocks
etcdctl --endpoints=$ENDPOINTS elect one p2

#状态
etcdctl --write-out=table --endpoints=$ENDPOINTS endpoint status
etcdctl --endpoints=$ENDPOINTS endpoint health





 
